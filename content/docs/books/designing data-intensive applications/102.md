---
weight: 2
title: "02: Data Models and Query Languages"
bookHidden: true
---

# Data Models and Query Languages
---

<div style="text-align: center;">
Data models are perhaps the most important part of developing software, because they have such a profound effect: not only on how the software is written, but also on how we think about the problem that we are solving.
</div>

Most applications are built by layering one data model on top of another.

![layers](/model_layers.png)


## Relational Model Versus Document Model


SQL, based on Edgar Codd's relational model from 1970, is the widely recognized and dominant data model for over 25-30 years.

The roots of relational databases lie in business data processing, which can be categorized into two main use cases:

{{< columns >}}
# Transaction Processing
- Entering sales or banking transactions
- Airline reservations
- Stock-keeping in warehouses

<--->

# Batch Processing
- Customer invoicing
- Payroll management
- Reporting
{{< /columns >}}

Over the years, there have been many competing approaches to data storage and querying:
- `Network model` (1970s-1980s)
- `Hierarchical model` (1970s-1980s)
- `Object databases` (brief resurgence in late 1980s and early 1990s)
- `XML databases` (limited adoption since early 2000s)

Relational databases have generalized well beyond business data processing and remain a key driving force behind the web today.

## The Birth of NoSQL

BOLD
NoSQL emerged as a challenge to the relational model's dominance. The term was coined in 2009 as a catchy hashtag for a meetup on nonrelational databases, encompassing various technologies beyond SQL. It stands for "Not Only SQL," representing a range of technologies beyond traditional relational databases.


Several driving forces behind the rise of NoSQL include:
- Need for greater scalability
- Widespread preference for free and open source software
- Specialized query operations
- Frustration with the restrictiveness of relational schemas



## Types of relationships

TABLE

One-to-One (1:1): Each record in Table A is associated with exactly one record in Table B, and vice versa.

An employee has one employee ID, and an employee ID is assigned to only one employee.

One-to-Many (1:N): Each record in Table A can be associated with multiple records in Table B, but each record in Table B is associated with only one record in Table A.

A customer can have multiple orders, but each order is associated with only one customer.

Many-to-One (N:1): Each record in Table A is associated with only one record in Table B, but each record in Table B can be associated with multiple records in Table A.

Multiple students can enroll in a single course, but each course is taught by only one instructor.

Many-to-Many (N:N): Multiple records in Table A can be associated with multiple records in Table B, and vice versa. This relationship is usually implemented using a bridge/junction table that connects the two tables.

A student can be enrolled in multiple courses, and each course can have multiple students.

### One-to-many relationship

Definition
The SQL data model faces criticism due to the impedance mismatch between relational tables and object-oriented programming languages. Object-oriented models represent data as objects with properties and methods, while relational models use tables with columns and rows. Flattening object hierarchies or joining multiple tables may be necessary. This requires a translation layer, like object-relational mapping (ORM) tools, adding complexity in handling data.

EXAMPLE
LinkedIn profile

- Unique identifier: user_id
- Columns on the users table: first_name, last_name
- One-to-many relationship from the user to: job positions, education

How to represent One-to-many relationship:
- Separate Tables: Positions, education, and contact information stored in separate tables with foreign key references.
- Structured Datatypes: SQL versions support structured datatypes, XML, and JSON for storing multi-valued data within a single row.
- JSON/XML as a text: Encode jobs, education, and contact info as JSON or XML documents stored in a text column in the database.


For a self-contained document-like data structure like a résumé, a JSON representation is appropriate. Document-oriented databases such as MongoDB, RethinkDB, CouchDB, and Espresso support this model. The JSON representation provides better data locality compared to a multi-table schema.

{
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ]
}



DEF
Data locality - storing all relevant information in one place, which facilitates efficient retrieval using a single query. 

### Many-to-One and Many-to-Many Relationships

DEF
As a rule of thumb, if you’re duplicating values that could be stored in just one place,
the schema is not normalized.

If we choose to normalize the data by replacing actual values with IDs and utilizing separate tables, there are several advantages:

- Standardization: Values are standardized, ensuring consistent style and avoiding ambiguity (e.g., cities with the same name).
- Ease of Updating: Data updates become easier as the values are stored in a single place.
- Localization Support: Standardized lists can be easily localized when the site is translated into different languages.

However, there are some drawbacks to normalization in the document model:

- Many-to-One Relationships: Normalizing data with many-to-one relationships is challenging in the document model.
- Join Limitations: Limited join support in document databases leads to complex joins emulated through multiple queries, impacting performance.
- Increasing Interconnections: Growing application features may require many-to-many relationships due to increasing data interconnections.

HISTORY
The hierarchical model in the 1970s was effective for one-to-many relationships but posed difficulties for many-to-many relationships and lacked join support. Developers had to decide whether to duplicate data or manually handle references to overcome these limitations.

The solutions proposed to address the limitations of the hierarchical model were:
- the relational model (SQL, which took over the world),
- the network model (CODASYL).

Relational and document databases both use unique identifiers (foreign keys in relational, document references in document) to represent many-to-one and many-to-many relationships.


## Relational Versus Document Databases Today

The main arguments in favor of the document data model are schema flexibility, better
performance due to locality, and that for some applications it is closer to the data
structures used by the application. The relational model counters by providing better
support for joins, and many-to-one and many-to-many relationships.

### Which data model leads to simpler application code?

For highly interconnected data, the document model can be awkward, the relational model is acceptable, and graph models are the most natural and intuitive choice.

### Schema

Schema-on-read:
- Data structure is implicit and interpreted during reading.
- Similar to dynamic (runtime) type checking.
- Used for collections with varying structures.

Schema-on-write:
- Relational databases enforce an explicit schema during data writing.
- Similar to static (compile-time) type checking.
- Schemas are valuable for documenting and enforcing consistent structure.

### Data locality for queries

Advantages of Locality:
- Better performance when accessing large parts of the document simultaneously.

Disadvantages of Locality:
- Updating the document often requires rewriting the entire document.
- It is advisable to keep documents small and avoid writes that increase document size to maintain performance.

Locality is utilized in other databases:
- Google's Spanner: Allows table rows to be interleaved or nested within a parent table for managing locality.
- Bigtable (used by Cassandra and HBase): Implements the column-family concept to manage locality.

### Future

Relational and document databases are becoming more similar over time. A hybrid approach combining relational and document models is beneficial for the future of databases.

## Query Languages for Data

### Imperitive vs. declarative

|                      | Declarative                             | Imperative                                     |
|----------------------|-----------------------------------------|------------------------------------------------|
| Used in              | SQL                                     | CODASYL, Many commonly used programming languages  |
| Definition           | You specify the pattern of the data you want but not how to achieve that goal   | An imperative language tells the computer to perform certain operations in a certain order  |
| Parallel Execution   | Good because the database is free to use a parallel implementation of the query language. CPUs are getting faster by adding more cores, not by running at significantly higher clock speeds  | Imperative code is very hard to parallelize across multiple cores and multiple machines because it specifies instructions that must be performed in a particular order. |


EXAMPLE CLICK

function getOtherAnimals() {
    var otherAnimals = [];
    for (var i = 0; i < animals.length; i++) {
        if (animals[i].family !== "Sharks") {
            otherAnimals.push(animals[i]);
        }
    }
    return otherAnimals;
}



SELECT *
FROM animals
WHERE family = 'Hipo';


### MapReduce Querying

MapReduce is a programming model used for processing large data sets across multiple machines. It combines elements of declarative and imperative approaches, using map and reduce functions. NoSQL datastores like MongoDB and CouchDB support a limited form of MapReduce. While higher-level query languages like SQL can be implemented using MapReduce, SQL is not restricted to single-machine execution. NoSQL systems may inadvertently resemble SQL in certain aspects.


### Graph-Like Data Models

We saw earlier that many-to-many relationships are an important distinguishing feature
between different data models. If your application has mostly one-to-many relationships
(tree-structured data) or no relationships between records, the document
model is appropriate.

49